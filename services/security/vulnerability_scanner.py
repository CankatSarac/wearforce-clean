"""
Vulnerability scanning and security assessment for WearForce platform.

This module provides comprehensive security scanning including dependency
vulnerability checks, code security analysis, infrastructure security
assessment, and continuous security monitoring.
"""

import asyncio
import json
import os
import subprocess
import tempfile
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union

import aiofiles
import aiohttp
import docker
import httpx
import redis
import structlog
import yaml
from packaging import version

logger = structlog.get_logger()


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"
    UNKNOWN = "unknown"


class ScanType(Enum):
    """Security scan types."""
    DEPENDENCY = "dependency"
    CONTAINER = "container"
    CODE = "code"
    INFRASTRUCTURE = "infrastructure"
    NETWORK = "network"
    CONFIGURATION = "configuration"


@dataclass
class Vulnerability:
    """Vulnerability finding."""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    affected_package: Optional[str] = None
    affected_version: Optional[str] = None
    fixed_version: Optional[str] = None
    references: List[str] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.now)
    scan_type: Optional[ScanType] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None


@dataclass
class ScanResult:
    """Security scan result."""
    scan_id: str
    scan_type: ScanType
    target: str
    started_at: datetime
    completed_at: Optional[datetime] = None
    status: str = "running"
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None
    
    @property
    def duration_seconds(self) -> Optional[float]:
        if self.completed_at and self.started_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None
    
    @property
    def vulnerability_counts(self) -> Dict[str, int]:
        counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        for vuln in self.vulnerabilities:
            counts[vuln.severity.value] += 1
        return counts


class DependencyScanner:
    """Scans dependencies for known vulnerabilities."""
    
    def __init__(self):
        self.safety_db_url = "https://pyup.io/safety/safety-db/"
        self.osv_api_url = "https://api.osv.dev/v1/query"
    
    async def scan_python_dependencies(self, requirements_file: str) -> List[Vulnerability]:
        """Scan Python dependencies using Safety and OSV database."""
        vulnerabilities = []
        
        try:
            # Parse requirements file
            with open(requirements_file, 'r') as f:
                requirements = f.readlines()
            
            # Extract package names and versions
            packages = self._parse_requirements(requirements)
            
            # Scan each package
            for package_name, package_version in packages:
                vulns = await self._check_package_vulnerabilities(
                    package_name, package_version, "pypi"
                )
                vulnerabilities.extend(vulns)
                
        except Exception as e:
            logger.error("Failed to scan Python dependencies", 
                        file=requirements_file, error=str(e))
        
        return vulnerabilities
    
    def _parse_requirements(self, requirements: List[str]) -> List[Tuple[str, str]]:
        """Parse requirements.txt file."""
        packages = []
        
        for line in requirements:
            line = line.strip()
            if line and not line.startswith('#'):
                # Simple parsing - could be enhanced for complex requirements
                if '==' in line:
                    name, ver = line.split('==', 1)
                    packages.append((name.strip(), ver.strip()))
                elif '>=' in line:
                    name, ver = line.split('>=', 1)
                    packages.append((name.strip(), ver.strip()))
                else:
                    # Package without version
                    packages.append((line.strip(), "latest"))
        
        return packages
    
    async def _check_package_vulnerabilities(self, 
                                           package_name: str, 
                                           package_version: str,
                                           ecosystem: str) -> List[Vulnerability]:
        """Check package vulnerabilities using OSV API."""
        vulnerabilities = []
        
        try:
            payload = {
                "package": {
                    "name": package_name,
                    "ecosystem": ecosystem.upper()
                },
                "version": package_version
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.osv_api_url,
                    json=payload,
                    timeout=30
                )
                
                if response.status_code == 200:
                    data = response.json()
                    
                    for vuln_data in data.get("vulns", []):
                        vulnerability = self._parse_osv_vulnerability(
                            vuln_data, package_name, package_version
                        )
                        vulnerabilities.append(vulnerability)
                        
        except Exception as e:
            logger.error("Failed to check package vulnerabilities",
                        package=package_name, error=str(e))
        
        return vulnerabilities
    
    def _parse_osv_vulnerability(self, 
                               vuln_data: Dict[str, Any], 
                               package_name: str,
                               package_version: str) -> Vulnerability:
        """Parse OSV vulnerability data."""
        severity = VulnerabilitySeverity.UNKNOWN
        cvss_score = None
        
        # Extract severity information
        if "severity" in vuln_data:
            severity_info = vuln_data["severity"]
            if isinstance(severity_info, list) and severity_info:
                severity_info = severity_info[0]
            
            if "score" in severity_info:
                cvss_score = float(severity_info["score"])
                
            if "type" in severity_info and severity_info["type"] == "CVSS_V3":
                if cvss_score >= 9.0:
                    severity = VulnerabilitySeverity.CRITICAL
                elif cvss_score >= 7.0:
                    severity = VulnerabilitySeverity.HIGH
                elif cvss_score >= 4.0:
                    severity = VulnerabilitySeverity.MEDIUM
                else:
                    severity = VulnerabilitySeverity.LOW
        
        # Extract references
        references = []
        for ref in vuln_data.get("references", []):
            if "url" in ref:
                references.append(ref["url"])
        
        # Extract fixed version
        fixed_version = None
        for event in vuln_data.get("database_specific", {}).get("events", []):
            if event.get("type") == "fixed":
                fixed_version = event.get("version")
                break
        
        return Vulnerability(
            id=vuln_data.get("id", "unknown"),
            title=vuln_data.get("summary", "Unknown vulnerability"),
            description=vuln_data.get("details", "No description available"),
            severity=severity,
            cvss_score=cvss_score,
            cve_id=vuln_data.get("aliases", [{}])[0] if vuln_data.get("aliases") else None,
            affected_package=package_name,
            affected_version=package_version,
            fixed_version=fixed_version,
            references=references,
            scan_type=ScanType.DEPENDENCY
        )


class ContainerScanner:
    """Scans container images for vulnerabilities."""
    
    def __init__(self):
        self.trivy_cmd = "trivy"
        self.docker_client = docker.from_env()
    
    async def scan_image(self, image_name: str, image_tag: str = "latest") -> List[Vulnerability]:
        """Scan container image using Trivy."""
        vulnerabilities = []
        full_image_name = f"{image_name}:{image_tag}"
        
        try:
            # Run Trivy scan
            cmd = [
                self.trivy_cmd, "image",
                "--format", "json",
                "--severity", "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL",
                full_image_name
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0:
                scan_data = json.loads(stdout.decode())
                vulnerabilities = self._parse_trivy_results(scan_data, full_image_name)
            else:
                logger.error("Trivy scan failed", 
                           image=full_image_name, 
                           error=stderr.decode())
                
        except Exception as e:
            logger.error("Container scan failed", 
                        image=full_image_name, error=str(e))
        
        return vulnerabilities
    
    def _parse_trivy_results(self, scan_data: Dict[str, Any], image_name: str) -> List[Vulnerability]:
        """Parse Trivy scan results."""
        vulnerabilities = []
        
        for result in scan_data.get("Results", []):
            target = result.get("Target", "")
            
            for vuln in result.get("Vulnerabilities", []):
                severity = self._map_trivy_severity(vuln.get("Severity", "UNKNOWN"))
                
                vulnerability = Vulnerability(
                    id=vuln.get("VulnerabilityID", "unknown"),
                    title=vuln.get("Title", "Unknown vulnerability"),
                    description=vuln.get("Description", "No description available"),
                    severity=severity,
                    cvss_score=self._extract_cvss_score(vuln),
                    cve_id=vuln.get("VulnerabilityID") if vuln.get("VulnerabilityID", "").startswith("CVE") else None,
                    affected_package=vuln.get("PkgName"),
                    affected_version=vuln.get("InstalledVersion"),
                    fixed_version=vuln.get("FixedVersion"),
                    references=vuln.get("References", []),
                    scan_type=ScanType.CONTAINER,
                    metadata={
                        "image": image_name,
                        "target": target,
                        "pkg_path": vuln.get("PkgPath", ""),
                    }
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _map_trivy_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Trivy severity to internal severity."""
        mapping = {
            "CRITICAL": VulnerabilitySeverity.CRITICAL,
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
            "UNKNOWN": VulnerabilitySeverity.UNKNOWN
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.UNKNOWN)
    
    def _extract_cvss_score(self, vuln: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability data."""
        cvss_data = vuln.get("CVSS", {})
        
        # Try CVSS v3 first, then v2
        for version in ["v3", "v2"]:
            if version in cvss_data:
                score = cvss_data[version].get("Score")
                if score is not None:
                    return float(score)
        
        return None


class CodeScanner:
    """Static code analysis for security vulnerabilities."""
    
    def __init__(self):
        self.bandit_cmd = "bandit"
        self.semgrep_cmd = "semgrep"
    
    async def scan_python_code(self, source_path: str) -> List[Vulnerability]:
        """Scan Python code using Bandit."""
        vulnerabilities = []
        
        try:
            cmd = [
                self.bandit_cmd,
                "-r", source_path,
                "-f", "json",
                "-o", "-"
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode in [0, 1]:  # 1 means issues found
                scan_data = json.loads(stdout.decode())
                vulnerabilities = self._parse_bandit_results(scan_data)
            else:
                logger.error("Bandit scan failed", 
                           path=source_path, 
                           error=stderr.decode())
                
        except Exception as e:
            logger.error("Code scan failed", path=source_path, error=str(e))
        
        return vulnerabilities
    
    async def scan_with_semgrep(self, source_path: str) -> List[Vulnerability]:
        """Scan code using Semgrep for broader security issues."""
        vulnerabilities = []
        
        try:
            cmd = [
                self.semgrep_cmd,
                "--config=auto",
                "--json",
                source_path
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode in [0, 1]:
                scan_data = json.loads(stdout.decode())
                vulnerabilities = self._parse_semgrep_results(scan_data)
            else:
                logger.error("Semgrep scan failed", 
                           path=source_path, 
                           error=stderr.decode())
                
        except Exception as e:
            logger.error("Semgrep scan failed", path=source_path, error=str(e))
        
        return vulnerabilities
    
    def _parse_bandit_results(self, scan_data: Dict[str, Any]) -> List[Vulnerability]:
        """Parse Bandit scan results."""
        vulnerabilities = []
        
        for result in scan_data.get("results", []):
            severity = self._map_bandit_severity(result.get("issue_severity", "LOW"))
            
            vulnerability = Vulnerability(
                id=f"bandit-{result.get('test_id', 'unknown')}",
                title=result.get("issue_text", "Security issue"),
                description=result.get("issue_text", "No description available"),
                severity=severity,
                scan_type=ScanType.CODE,
                file_path=result.get("filename"),
                line_number=result.get("line_number"),
                metadata={
                    "test_id": result.get("test_id"),
                    "test_name": result.get("test_name"),
                    "confidence": result.get("issue_confidence"),
                    "more_info": result.get("more_info")
                }
            )
            
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _parse_semgrep_results(self, scan_data: Dict[str, Any]) -> List[Vulnerability]:
        """Parse Semgrep scan results."""
        vulnerabilities = []
        
        for result in scan_data.get("results", []):
            severity = self._map_semgrep_severity(result.get("severity", "INFO"))
            
            vulnerability = Vulnerability(
                id=f"semgrep-{result.get('check_id', 'unknown')}",
                title=result.get("message", "Security issue"),
                description=result.get("message", "No description available"),
                severity=severity,
                scan_type=ScanType.CODE,
                file_path=result.get("path"),
                line_number=result.get("start", {}).get("line"),
                metadata={
                    "check_id": result.get("check_id"),
                    "rule_id": result.get("rule_id"),
                    "fix": result.get("fix"),
                    "start": result.get("start"),
                    "end": result.get("end")
                }
            )
            
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Bandit severity to internal severity."""
        mapping = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.LOW)
    
    def _map_semgrep_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Semgrep severity to internal severity."""
        mapping = {
            "ERROR": VulnerabilitySeverity.HIGH,
            "WARNING": VulnerabilitySeverity.MEDIUM,
            "INFO": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.LOW)


class InfrastructureScanner:
    """Infrastructure security scanning."""
    
    def __init__(self):
        self.nmap_cmd = "nmap"
    
    async def scan_network_ports(self, target: str) -> List[Vulnerability]:
        """Scan network ports for security issues."""
        vulnerabilities = []
        
        try:
            cmd = [
                self.nmap_cmd,
                "-sS", "-O", "-sV",
                "--script", "vuln",
                "-oX", "-",
                target
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0:
                # Parse nmap XML output
                vulnerabilities = self._parse_nmap_results(stdout.decode())
            else:
                logger.error("Nmap scan failed", 
                           target=target, 
                           error=stderr.decode())
                
        except Exception as e:
            logger.error("Network scan failed", target=target, error=str(e))
        
        return vulnerabilities
    
    async def scan_ssl_configuration(self, hostname: str, port: int = 443) -> List[Vulnerability]:
        """Scan SSL/TLS configuration."""
        vulnerabilities = []
        
        try:
            # Use testssl.sh or similar tool
            cmd = [
                "testssl.sh",
                "--jsonfile-pretty", "-",
                f"{hostname}:{port}"
            ]
            
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0:
                scan_data = json.loads(stdout.decode())
                vulnerabilities = self._parse_testssl_results(scan_data)
                
        except Exception as e:
            logger.warning("SSL scan failed", hostname=hostname, error=str(e))
        
        return vulnerabilities
    
    def _parse_nmap_results(self, xml_output: str) -> List[Vulnerability]:
        """Parse nmap XML results."""
        vulnerabilities = []
        # This would need XML parsing implementation
        # For now, return empty list
        return vulnerabilities
    
    def _parse_testssl_results(self, scan_data: List[Dict[str, Any]]) -> List[Vulnerability]:
        """Parse testssl.sh results."""
        vulnerabilities = []
        
        for result in scan_data:
            if result.get("severity") in ["HIGH", "CRITICAL", "MEDIUM"]:
                severity = self._map_testssl_severity(result.get("severity"))
                
                vulnerability = Vulnerability(
                    id=f"ssl-{result.get('id', 'unknown')}",
                    title=result.get("finding", "SSL/TLS issue"),
                    description=result.get("finding", "SSL/TLS configuration issue"),
                    severity=severity,
                    scan_type=ScanType.INFRASTRUCTURE,
                    metadata={
                        "protocol": result.get("protocol"),
                        "cve": result.get("cve"),
                        "cwe": result.get("cwe")
                    }
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _map_testssl_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map testssl severity to internal severity."""
        mapping = {
            "CRITICAL": VulnerabilitySeverity.CRITICAL,
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
            "INFO": VulnerabilitySeverity.INFO
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.UNKNOWN)


class VulnerabilityManager:
    """Main vulnerability management system."""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.dependency_scanner = DependencyScanner()
        self.container_scanner = ContainerScanner()
        self.code_scanner = CodeScanner()
        self.infrastructure_scanner = InfrastructureScanner()
        
        self.scan_results: Dict[str, ScanResult] = {}
        
    async def scan_dependencies(self, requirements_file: str) -> ScanResult:
        """Scan application dependencies."""
        scan_id = f"dep-{int(time.time())}"
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.DEPENDENCY,
            target=requirements_file,
            started_at=datetime.now()
        )
        
        try:
            vulnerabilities = await self.dependency_scanner.scan_python_dependencies(
                requirements_file
            )
            scan_result.vulnerabilities = vulnerabilities
            scan_result.status = "completed"
            
        except Exception as e:
            scan_result.error = str(e)
            scan_result.status = "failed"
            logger.error("Dependency scan failed", error=str(e))
        finally:
            scan_result.completed_at = datetime.now()
        
        await self._store_scan_result(scan_result)
        return scan_result
    
    async def scan_container_images(self, images: List[Tuple[str, str]]) -> ScanResult:
        """Scan container images for vulnerabilities."""
        scan_id = f"container-{int(time.time())}"
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.CONTAINER,
            target=f"{len(images)} images",
            started_at=datetime.now()
        )
        
        try:
            all_vulnerabilities = []
            
            for image_name, image_tag in images:
                vulnerabilities = await self.container_scanner.scan_image(
                    image_name, image_tag
                )
                all_vulnerabilities.extend(vulnerabilities)
            
            scan_result.vulnerabilities = all_vulnerabilities
            scan_result.status = "completed"
            
        except Exception as e:
            scan_result.error = str(e)
            scan_result.status = "failed"
            logger.error("Container scan failed", error=str(e))
        finally:
            scan_result.completed_at = datetime.now()
        
        await self._store_scan_result(scan_result)
        return scan_result
    
    async def scan_source_code(self, source_path: str) -> ScanResult:
        """Scan source code for security vulnerabilities."""
        scan_id = f"code-{int(time.time())}"
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.CODE,
            target=source_path,
            started_at=datetime.now()
        )
        
        try:
            # Run multiple code scanners
            bandit_vulns = await self.code_scanner.scan_python_code(source_path)
            semgrep_vulns = await self.code_scanner.scan_with_semgrep(source_path)
            
            all_vulnerabilities = bandit_vulns + semgrep_vulns
            scan_result.vulnerabilities = all_vulnerabilities
            scan_result.status = "completed"
            
        except Exception as e:
            scan_result.error = str(e)
            scan_result.status = "failed"
            logger.error("Code scan failed", error=str(e))
        finally:
            scan_result.completed_at = datetime.now()
        
        await self._store_scan_result(scan_result)
        return scan_result
    
    async def scan_infrastructure(self, targets: List[str]) -> ScanResult:
        """Scan infrastructure for security issues."""
        scan_id = f"infra-{int(time.time())}"
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.INFRASTRUCTURE,
            target=f"{len(targets)} targets",
            started_at=datetime.now()
        )
        
        try:
            all_vulnerabilities = []
            
            for target in targets:
                # Network scan
                network_vulns = await self.infrastructure_scanner.scan_network_ports(target)
                all_vulnerabilities.extend(network_vulns)
                
                # SSL scan if it looks like a hostname
                if not target.replace('.', '').replace(':', '').isdigit():
                    ssl_vulns = await self.infrastructure_scanner.scan_ssl_configuration(target)
                    all_vulnerabilities.extend(ssl_vulns)
            
            scan_result.vulnerabilities = all_vulnerabilities
            scan_result.status = "completed"
            
        except Exception as e:
            scan_result.error = str(e)
            scan_result.status = "failed"
            logger.error("Infrastructure scan failed", error=str(e))
        finally:
            scan_result.completed_at = datetime.now()
        
        await self._store_scan_result(scan_result)
        return scan_result
    
    async def run_comprehensive_scan(self, config: Dict[str, Any]) -> Dict[str, ScanResult]:
        """Run comprehensive security scan."""
        results = {}
        
        # Dependency scan
        if "requirements_file" in config:
            results["dependencies"] = await self.scan_dependencies(
                config["requirements_file"]
            )
        
        # Container scan
        if "container_images" in config:
            results["containers"] = await self.scan_container_images(
                config["container_images"]
            )
        
        # Code scan
        if "source_path" in config:
            results["code"] = await self.scan_source_code(
                config["source_path"]
            )
        
        # Infrastructure scan
        if "infrastructure_targets" in config:
            results["infrastructure"] = await self.scan_infrastructure(
                config["infrastructure_targets"]
            )
        
        # Generate summary report
        await self._generate_summary_report(results)
        
        return results
    
    async def _store_scan_result(self, scan_result: ScanResult):
        """Store scan result in Redis."""
        try:
            result_data = {
                "scan_id": scan_result.scan_id,
                "scan_type": scan_result.scan_type.value,
                "target": scan_result.target,
                "started_at": scan_result.started_at.isoformat(),
                "completed_at": scan_result.completed_at.isoformat() if scan_result.completed_at else None,
                "status": scan_result.status,
                "duration_seconds": scan_result.duration_seconds,
                "vulnerability_counts": scan_result.vulnerability_counts,
                "total_vulnerabilities": len(scan_result.vulnerabilities),
                "error": scan_result.error,
                "metadata": scan_result.metadata
            }
            
            # Store summary
            await self.redis.setex(
                f"scan_result:{scan_result.scan_id}",
                7 * 24 * 3600,  # 7 days
                json.dumps(result_data)
            )
            
            # Store detailed vulnerabilities
            if scan_result.vulnerabilities:
                vuln_data = []
                for vuln in scan_result.vulnerabilities:
                    vuln_dict = {
                        "id": vuln.id,
                        "title": vuln.title,
                        "description": vuln.description,
                        "severity": vuln.severity.value,
                        "cvss_score": vuln.cvss_score,
                        "cve_id": vuln.cve_id,
                        "affected_package": vuln.affected_package,
                        "affected_version": vuln.affected_version,
                        "fixed_version": vuln.fixed_version,
                        "references": vuln.references,
                        "discovered_at": vuln.discovered_at.isoformat(),
                        "scan_type": vuln.scan_type.value if vuln.scan_type else None,
                        "file_path": vuln.file_path,
                        "line_number": vuln.line_number
                    }
                    vuln_data.append(vuln_dict)
                
                await self.redis.setex(
                    f"scan_vulnerabilities:{scan_result.scan_id}",
                    7 * 24 * 3600,  # 7 days
                    json.dumps(vuln_data)
                )
            
            # Update scan history
            await self.redis.zadd(
                "scan_history",
                {scan_result.scan_id: time.time()}
            )
            
            # Keep only last 100 scans
            await self.redis.zremrangebyrank("scan_history", 0, -101)
            
        except Exception as e:
            logger.error("Failed to store scan result", 
                        scan_id=scan_result.scan_id, error=str(e))
    
    async def _generate_summary_report(self, results: Dict[str, ScanResult]):
        """Generate security summary report."""
        summary = {
            "generated_at": datetime.now().isoformat(),
            "scans": len(results),
            "total_vulnerabilities": sum(len(r.vulnerabilities) for r in results.values()),
            "severity_breakdown": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0,
                "unknown": 0
            },
            "scan_types": {},
            "recommendations": []
        }
        
        for scan_type, result in results.items():
            summary["scan_types"][scan_type] = result.vulnerability_counts
            
            for severity, count in result.vulnerability_counts.items():
                summary["severity_breakdown"][severity] += count
        
        # Generate recommendations
        if summary["severity_breakdown"]["critical"] > 0:
            summary["recommendations"].append(
                "URGENT: Critical vulnerabilities found. Immediate action required."
            )
        
        if summary["severity_breakdown"]["high"] > 5:
            summary["recommendations"].append(
                "High priority: Multiple high-severity vulnerabilities require attention."
            )
        
        # Store summary
        await self.redis.setex(
            "security_summary",
            24 * 3600,  # 24 hours
            json.dumps(summary)
        )
        
        logger.info("Security summary generated", 
                   total_vulns=summary["total_vulnerabilities"],
                   critical=summary["severity_breakdown"]["critical"])
    
    async def get_scan_result(self, scan_id: str) -> Optional[ScanResult]:
        """Get scan result by ID."""
        try:
            result_data = await self.redis.get(f"scan_result:{scan_id}")
            if not result_data:
                return None
            
            data = json.loads(result_data)
            
            # Get detailed vulnerabilities
            vuln_data = await self.redis.get(f"scan_vulnerabilities:{scan_id}")
            vulnerabilities = []
            
            if vuln_data:
                vuln_list = json.loads(vuln_data)
                for vuln_dict in vuln_list:
                    vulnerability = Vulnerability(
                        id=vuln_dict["id"],
                        title=vuln_dict["title"],
                        description=vuln_dict["description"],
                        severity=VulnerabilitySeverity(vuln_dict["severity"]),
                        cvss_score=vuln_dict["cvss_score"],
                        cve_id=vuln_dict["cve_id"],
                        affected_package=vuln_dict["affected_package"],
                        affected_version=vuln_dict["affected_version"],
                        fixed_version=vuln_dict["fixed_version"],
                        references=vuln_dict["references"],
                        discovered_at=datetime.fromisoformat(vuln_dict["discovered_at"]),
                        scan_type=ScanType(vuln_dict["scan_type"]) if vuln_dict["scan_type"] else None,
                        file_path=vuln_dict["file_path"],
                        line_number=vuln_dict["line_number"]
                    )
                    vulnerabilities.append(vulnerability)
            
            scan_result = ScanResult(
                scan_id=data["scan_id"],
                scan_type=ScanType(data["scan_type"]),
                target=data["target"],
                started_at=datetime.fromisoformat(data["started_at"]),
                completed_at=datetime.fromisoformat(data["completed_at"]) if data["completed_at"] else None,
                status=data["status"],
                vulnerabilities=vulnerabilities,
                metadata=data.get("metadata", {}),
                error=data.get("error")
            )
            
            return scan_result
            
        except Exception as e:
            logger.error("Failed to get scan result", scan_id=scan_id, error=str(e))
            return None
    
    async def get_security_metrics(self) -> Dict[str, Any]:
        """Get security metrics for monitoring."""
        try:
            # Get recent scan results
            scan_ids = await self.redis.zrevrange("scan_history", 0, 9)  # Last 10 scans
            
            metrics = {
                "recent_scans": len(scan_ids),
                "vulnerability_trends": {},
                "scan_success_rate": 0.0,
                "average_scan_duration": 0.0,
                "critical_vulnerabilities": 0,
                "high_vulnerabilities": 0
            }
            
            if scan_ids:
                successful_scans = 0
                total_duration = 0
                total_critical = 0
                total_high = 0
                
                for scan_id in scan_ids:
                    result_data = await self.redis.get(f"scan_result:{scan_id}")
                    if result_data:
                        data = json.loads(result_data)
                        
                        if data["status"] == "completed":
                            successful_scans += 1
                            
                        if data.get("duration_seconds"):
                            total_duration += data["duration_seconds"]
                        
                        counts = data.get("vulnerability_counts", {})
                        total_critical += counts.get("critical", 0)
                        total_high += counts.get("high", 0)
                
                metrics["scan_success_rate"] = successful_scans / len(scan_ids)
                metrics["average_scan_duration"] = total_duration / len(scan_ids) if scan_ids else 0
                metrics["critical_vulnerabilities"] = total_critical
                metrics["high_vulnerabilities"] = total_high
            
            return metrics
            
        except Exception as e:
            logger.error("Failed to get security metrics", error=str(e))
            return {}


# Background task for automated scanning
async def automated_security_scan_task(vuln_manager: VulnerabilityManager, 
                                     scan_config: Dict[str, Any],
                                     interval_hours: int = 24):
    """Background task for automated security scanning."""
    logger.info("Starting automated security scan task", interval_hours=interval_hours)
    
    while True:
        try:
            logger.info("Starting automated security scan")
            
            results = await vuln_manager.run_comprehensive_scan(scan_config)
            
            # Check for critical vulnerabilities and alert
            for scan_type, result in results.items():
                critical_count = result.vulnerability_counts.get("critical", 0)
                if critical_count > 0:
                    logger.error("Critical vulnerabilities found", 
                               scan_type=scan_type, 
                               critical_count=critical_count)
            
            logger.info("Automated security scan completed", 
                       scans=len(results))
            
        except Exception as e:
            logger.error("Automated security scan failed", error=str(e))
        
        # Wait for next scan
        await asyncio.sleep(interval_hours * 3600)


# Utility functions
async def setup_vulnerability_scanning(redis_client: redis.Redis) -> VulnerabilityManager:
    """Set up vulnerability scanning system."""
    vuln_manager = VulnerabilityManager(redis_client)
    
    # Default scan configuration
    scan_config = {
        "requirements_file": "requirements.txt",
        "container_images": [
            ("wearforce-clean/crm", "latest"),
            ("wearforce-clean/erp", "latest"),
            ("wearforce-clean/notification", "latest"),
            ("wearforce-clean/graphql", "latest")
        ],
        "source_path": "./",
        "infrastructure_targets": [
            "localhost",
            "api.wearforce-clean.com",
            "app.wearforce-clean.com"
        ]
    }
    
    # Start automated scanning (daily)
    asyncio.create_task(
        automated_security_scan_task(vuln_manager, scan_config, 24)
    )
    
    logger.info("Vulnerability scanning system initialized")
    return vuln_manager